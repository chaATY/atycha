# 已阅读完的书

每一本阅读的书都要整理到笔记中，完善笔记内容

# 随笔

https://www.zhihu.com/question/333560253/answer/2966514742?utm_id=0

1. rtk-framework 是对Android framework 的补充，提供芯片厂商提供的接口，编译时打包成动态Jar包
2. FPS游戏：Yolo FOV PID算法
3. 写脚本 通过截取小地图拼接制作大地图
4. 联想宽带完美酒店套餐，每个房间号独立IP地址每个IP每个月5元左右 或者 使用软路由
5. 图色检测手段
   1. 堆栈检测
   2. 数据检测
   3. CRC检测
   4. 注入检测
   5. 类名与特征码检测
   6. 大数据收集非法指令
   7. 框口检测-是否游戏窗口被绑定
   8. 附加程序检测-附加非法组件或非法程序
   9. 文件扫描检测-根目录下 2层3层多层文件夹内有没有危险DLL或者是危险EXE
   10. 键鼠调用检测-API函数直接调用键鼠-远程调用键鼠
   11. 账号与IP检测-同一IP批量注册-同一IP下多账号玩游戏
   12. 大数据收集行为检测-动作与任务过于机械化
6. 图色防封处理
   1. 虚拟机（分离执行）-虚拟机使用'硬件信息修改大师'
      1. 切勿在虚拟机中运行辅助软件与各种插件工具等，不要存储有辅助软件或各种插件工具等，虚拟机保持纯净环境
      2. 选择虚拟机后手动测试一段时间（版本）
      3. 禁止虚拟机内运行无关程序与进程
      4. VNC不要使用
      5. 物理键鼠操作
      6. 保证最纯净，真机状态（重要）
      7. vmx文件打开方式使用右键-VMware Player
   2. 图色插件-乐玩、图灵、大漠
   3. 双头盒子
   4. 软路由
      1. PE启动U盘
      2. 登陆爱快（https://www.ikuai8.com）官网下载ghost
      3. 下载64位GHOST
      4. 创建虚拟机还原爱快GHOST
      5. 设置添加爱快虚拟机网卡
      6. 设置单虚拟机单IP
   5. Ocr
   6. Yolo-离火综合工具
      1. 除了1650 1660 只能勇CUDA10，其余版本N卡可以勇CUDA11
      2. A卡和集成显卡是不能训练的
      3. 不推荐CPU训练
   7. 自建IP-单窗口单IP（多人使用）-独享IP（1～3人）-自己搭建IP（个人）
      1. 有一个天翼云（电信）打折账号
      2. 申请云主机，申请IP，申请IP共用带宽
      3. 在自己的云主机上搭建IP FinalShell工具下载
      4. ifconfig eth0:1 10.0.0.11 up
      5. 软路由设置分配自建IP
      6. 实现单虚拟机单IP
7. Python键鼠操作：
   1. [OP插件](https://gitee.com/yenmuse/op)
   2. win32-GDI（GDI 接口比较灵活，可以截取指定窗口，哪怕窗口被遮挡或位于显示区域外，但兼容性较低，无法截取 DX 接口输出的画面。）
   3. MSS
   4. DXGI 截屏（D3DShot）
   5. dx下钩子捕获后缓冲(OBS Studio，一般用来捕获游戏)
   6. 穿透鼠标实现后台点击，适用于任何窗口！【后台鼠标】【风雪】

```
也许你就是被这标题吸引来的，呵呵！
好久没发帖了，勾引一下大家的胃口，当然有的人已经猜出原理了！
既然来了，都要把原理学回家，不然就没意思了！
很多游戏现在都不支持后台消息鼠标，要实现真的不是简单的，什么注入dll啊，什么hook俺也学不懂，那就简简单单另辟蹊径了
下面来讲讲原理吧(下面的玩玩可以，用于实际不现实，俺也不藏了，看到这么多人回复，良心过意不去，呵呵)
首先，将要点击的窗口上面覆盖的所有窗口，由一般模式变成置顶模式
SetWindowPos temp, -1, 0, 0, 0, 0, 1 Or 2  '置顶
然后再变成分层窗口的鼠标穿透模式
ret = GetWindowLong(temp, GWL_EXSTYLE)
ret = ret Or WS_EX_TRANSPARENT Or WS_EX_LAYERED
SetWindowLong temp, GWL_EXSTYLE, ret
SetLayeredWindowAttributes temp, 0, 255, LWA_ALPHA
这样鼠标相应时，只相应你设定的那个窗口，上面所覆盖的窗口只是视觉上的，从而实现后台点击！
上面为什么要置顶？
答：不置顶的话，你点击时，就激活了你选中的窗口，窗口就自动前置了，变前台了就没意思了
为什么要先置顶，后分层？
答：这个是测试了好多次，要是先分层后置顶，无法实现置顶
如何获得覆盖在上面的窗口句柄？
答：获得一个分层一个，分层后就会被忽略 WindowFromPoint(X, Y)，形同透明
总结一下：上面就是主要用到的API，其中分层的那个API，对视屏以及dX画面的作用，只有专业人士才能评论，因为我确实不懂，视频会变黑，DX画面会花屏，我的解决办法就是某某某曾经提过的，将窗口的任何一点拖到屏幕外就OK了
以下是我把它做成插件，可供大家练习使用，或许你会有更好的创意，到时可不要独自享受哦！
```

8. [Python Apex Legends AI 自瞄 全过程记录](https://www.iotword.com/6521.html)
9. Qt鼠标穿透：鼠标穿透的意思是所有鼠标键盘操作全部会穿透窗口到下方窗口，一种是穿透到父窗口，一种是穿透到桌面。
   1. 穿透到父窗口：
   2. 当前窗口及子控件均不响应鼠标事件：setAttribute(Qt::WA_TransparentForMouseEvents, true);
   3. 当前窗口透明区域不响应鼠标事件：setWindowFlags(Qt::FramelessWindowHint | Qt::Tool);setAttribute(Qt::WA_TranslucentBackground, true);
   4. 自定义当前窗口区域响应鼠标事件：void QWidget::setMask(const QRegion &region) 注意：如果设置的区域很复杂，效果可能会很慢。
10. [Qt透明窗口鼠标穿透问题及解决办法](https://blog.csdn.net/zy1551/article/details/132101930?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-1-132101930-blog-117919649.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-1-132101930-blog-117919649.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=2)
11. 根据游戏情况来 VNC优势可以双机也可以虚拟机 vnc是vmware底层支持的
12. 锁帧

```
1.  就是让游戏输出的帧数，稳定在某个帧数。关于游戏锁帧，大致可以分为两类：
2.  游戏内置锁帧，游戏开发者主动限制游戏帧数上限，日系游戏较多，如：黑魂系列;
3.  通过RTSS等软件工具锁定帧数，欧美系游戏较多，如：巫师系列等。
4.  在对游戏进行锁帧之后，玩家普遍都认为游戏体验变得更加稳定和流畅，其次是能够降低显卡负载减少发热，而且还能减少画面撕裂。锁帧一把双刃剑，虽然增加了游戏体验，但是却失去高端显卡所提供的性能体验。当然具体合不合适还要看游戏本身的硬件需求。
5.  认为锁帧增加了游戏体验的原理是：当你在 60 FPS 的游戏画面下，突然遇到了复杂的游戏情景，画面降到了 30 FPS，你就会觉得画面卡顿，从而觉得游戏体验差
```

游戏：

```
NPC:
    1.人类-AI行为：
    ●勇气系数
    ●性格
    ●战斗类
    ●生活类
    ●娱乐类
    ●犯罪类
人类：
    1.战斗天赋、生活天赋、犯罪类天赋
    2.学习系数-影响熟练度
世界：
    1.科技线发展？/超凡发展？
    2.国家-城镇（最小势力范围）-经济系统

杂记：
    ●换皮，需要剥皮
    ●科技、类克苏鲁生物，诡异（规则类生物）、污染值
    ●多个大世界，穿越平行宇宙会导致其他宇宙时间暂停
    ●神道，香火祭祀
```

**脚本流程：**

```
1.识别地图路线
2.获取人物坐标，判断人物是否在 有效路径上（可以行走的坐标组，offset=5，也可以在几个回城点附近都画成有效路径）
3.如果是：根据A*算法获取目的地路线坐标组
4.while A*算法: 
5.获取人物角度，和最近有效坐标的角度。
6.改变方向，计算如果角度差大于90度则停下前进然后直接转向，否则直接调整
7.按住W开始跑到指定地点（偏差是5，如果没有距离偏差那么像素点太小会导致人物移动时无法准确判断人物移动到哪里）

优化获取坐标方法
  最好用灰度图，确认上下左右四个边的像素值，在大地图的灰度图上进行对比。相似度和偏差（2个像素的间距）在5个像素内。

优化获取人物角度方法
  人物光标在小地图中间，获取小地图中间坐标值。通过像素rgb值确定当前人物方向
（偏差在？），之后可以记录下来，下次直接匹配已确认过的角度对应的像素点坐标

给你方案，用opencv在同一个方位角，把当前北
背景地图合成大地图，然后匹配当前地图特征点匹配大地图的所在位置实现定位。

初学是线性，实际上真正好用的是把线性打散成各个分段，然后提取特征并都放进一个handle，让程序自己根据条件去完成一个线性事件。因为两件事情并不是强相关，当失去同步后更细的分段有助于让程序快速同步，而不是浪费时间去等待一个很长的时间直到可以同步的节点出现
```

**键鼠**

```
sendinput和mouseevent区别
SendInput和mouse_event都可以用于模拟鼠标事件，它们的主要区别在于：

SendInput是Windows操作系统提供的API，而mouse_event是Win32 SendInput的精度比mouse_event更高，可以模拟出更精确的鼠标操作。

SendInput可以通过异步方式模拟鼠标事件，而mouse_event只能同步方式模拟。

因此，如果需要模拟多种输入设备事件或需要精确模拟鼠标操作，建议使用SendInput。如果只需要模拟鼠标事件并且需求不是很高，则可以使用mouse_event。
```

```
WIN10可以用VHF模拟键盘鼠标。就是一个HID设备。
虚拟 HID 框架（Virtual HID Framework，VHF）是一种用于创建和管理虚拟人机接口设备（HID）的框架。HID 是一种通用的设备接口标准，用于连接和通信各种输入设备（如键盘、鼠标、游戏手柄等）和输出设备（如显示器、震动反馈等）。
VHF 提供了一种软件方法来模拟和管理虚拟 HID 设备，从而可以扩展计算机的输入和输出功能。通过 VHF，开发人员可以创建虚拟 HID 设备，使其在操作系统中被识别为实际的物理设备。这些虚拟设备可以接收和发送与实际 HID 设备相同的输入和输出信号。
使用 VHF，开发人员可以创建各种自定义的虚拟 HID 设备，以满足特定的需求。例如，可以创建一个虚拟键盘设备，用于自动化文本输入或模拟按键操作；或者创建一个虚拟游戏手柄设备，用于模拟游戏控制器的输入信号。
VHF 在虚拟化技术、仿真和测试等领域具有广泛的应用。它可以用于开发游戏、模拟器、虚拟现实应用等，也可以用于测试和调试硬件设备驱动程序。
总而言之，虚拟 HID 框架（VHF）是一个用于创建和管理虚拟 HID 设备的框架，可以扩展计算机的输入和输出功能，并在虚拟化、仿真和测试等领域发挥重要作用。

参考文档：
https://bbs.kanxue.com/thread-220492.htm
https://www.usbzh.com/article/detail-511.html
https://www.usbzh.com/article/detail-476.html
https://www.zhihu.com/question/516168293
https://learn.microsoft.com/zh-cn/windows-hardware/drivers/hid/virtual-hid-framework--vhf-
https://bbs.kanxue.com/thread-81712.htm
https://blog.csdn.net/qq_56637962/article/details/120889628
https://blog.csdn.net/THMAIL/article/details/113812698

//TSR-Start
要在虚拟机中连接 HID 虚拟鼠标，您可以按照以下步骤进行操作：
确保您的虚拟机软件支持传递 HID 设备给虚拟机。大多数虚拟机软件都支持此功能，但具体步骤可能会有所不同。请查阅您所使用的虚拟机软件的文档或设置来了解详细信息。
通过将物理鼠标连接到主机计算机，或者通过使用支持 HID 设备的 USB 转接器来模拟 HID 设备。
打开虚拟机软件，并进入虚拟机的设置或配置页面。
在虚拟机的设置或配置页面中，找到 USB 设备或设备连接选项。这通常位于虚拟机软件的硬件或设备选项下。
在 USB 设备或设备连接选项中，启用对 HID 设备的传递。这通常可以通过勾选相应的复选框来完成。
将 HID 虚拟鼠标设备连接到虚拟机。在虚拟机中，您应该能够看到虚拟鼠标被识别为一个可用的输入设备。
确保虚拟机中的操作系统正确识别和配置了 HID 虚拟鼠标。您可能需要安装相应的驱动程序或进行一些设置来启用和使用虚拟鼠标。
完成上述步骤后，您应该能够在虚拟机中使用 HID 虚拟鼠标进行鼠标操作。请注意，具体步骤可能因使用的虚拟机软件而有所不同，因此请参考您的虚拟机软件的文档或设置以获取准确的操作指南。
//TSR-End
```

```
网络游戏出于对控制输入速度的和反外挂的目的，对于鼠标键盘的输入越过了消息传递等正常的途径层
次，所以一般的常用如下控制鼠标键盘的API函数
::SetCursorPos(pEvent->xPos, pEvent->yPos);
::SendInput(1, &Input, sizeof(INPUT));
::PostMessage(hwnd,WM_KEYDOWN, VK_ESC ,0L); //发送ESC按下的键盘消息

是无法实现目的的，解决问题的方法只有越过应用层面，从系统驱动层解决问题，目前的方法主要有
1.分别写个鼠标和键盘驱动设备，但在在系统设备管理器中出现一个鼠标和一个键盘设备
2.用winio软件包直接控制鼠标键盘硬件端口，这种方法要求本身的硬件鼠标不可以动，否则就鼠标满天
飞，只有重启电脑了

我提供的鼠标键盘驱动最大的特点就是：

1.虚拟鼠标和虚拟键盘一个驱动里完成
2.在设备管理器里隐藏掉所虚拟的鼠标键盘设备
3.通过了NP和Xtrap测试

难度用上驱动就不肤浅？你GOOGLEBAIDU “模拟键盘鼠标 驱动” 看看高深到哪里。直接端口只需用10行左右汇编代码。

前言：

有一些使用DirectX接口的游戏程序，它们在读取键盘操作时绕过了windows的消息机制，而使用DirectInput.这是因为有些游戏对实时性控制的要求比较高，比如赛车游戏，要求以最快速度响应键盘输入。而windows消息由于是队列形式的，消息在传递时会有不少延迟，有时1秒钟也就传递十几条消息，这个速度达不到游戏的要求。而DirectInput则绕过了windows消息，直接与键盘驱动程序打交道，效率当然提高了不少。因此也就造成，对这样的程序无论用PostMessage或者是keybd_event都不会有反应，因为这些函数都在较高层。对于这样的程序，只好用直接读写键盘端口的方法来模拟硬件事件了。要用这个方法来模拟键盘，需要先了解一下键盘编程的相关知识。

 

先从最简单的模拟操作讲起
模拟键盘鼠标有很多方法，我大体分为消息模拟、API模拟、驱动模拟
对于网页的话还可以用JavaScript模拟，虽然这不在本教程范围


三   驱动模拟
驱动模拟就是自己写驱动程序，在系统内核里面操作I/O端口，给连接键盘的集成电路（一般是8042芯片）发送指令，让它产生一个按下按键的信息，这样你的模拟输入对于所有程序来说就是从一个真实的设备发出的，而且可以绕过很多保护
（需要操作I/O端口的话可以学习一下WinIo库）
然而我并不会写这种驱动_(:з」∠)_，而且x64系统中加载驱动需要有可信任的数字签名，否则会比较麻烦，而且还要知道8042芯片相关的底层知识...
所以我找了个别人写的库实现驱动模拟
Interception官网
Interception API的Git库

它的驱动有数字签名而且在XP到win10的平台上都测试过了
它还可以拦截并修改输入（包括CTRL+ALT+DELETE），不过这里我只讲模拟输入所以自己研究吧...
（好像它的模拟输入也不是操作端口而是内核版的SendInput？）
```

[DirectX11 输入设备——DirectInput检测鼠标、键盘状态_pydirectinput鼠标会被屏蔽吗-CSDN博客](https://blog.csdn.net/sinat_24229853/article/details/47046581)
Git项目：
[使用yolov5自动瞄准，支持fps游戏 鼠标移动控制需要自行调整 项目](https://github.com/soloist-v/AutoStrike/tree/main/tools/mouse)
[tensorflow实践：梦幻西游人物弹窗识别](https://gitee.com/miketickle/mhxy)
[kmclass键鼠驱动](https://github.com/BestBurning/kmclass)
[HIDDriver虚拟鼠标键盘驱动程序](https://github.com/dengqizhou30/HIDDriver)
[Hook DirectInput-&gt;CreateDevice-&gt;GetDeviceData解决方案-CSDN博客](https://blog.csdn.net/xuq09/article/details/94128892)
[[原创]《狂人的Windows内核调试秘诀》试读-软件逆向-看雪-安全社区|安全招聘|kanxue.com](https://bbs.kanxue.com/thread-276169.htm)

```
其中 R3的方法有：
1. keybd_event/mouse_event，SendInput
keybd_event/mouse_event 内部其实是调用了SendInput。，所发消息是发给Active window的。 发消息之前需要将窗口置顶。

2. SendMessage/PostMessage
SendMessage和PostMessage是User32.dll中的函数。可以直接在程序中调用，实现对另一个软件上的按钮的点击。给窗口句柄发送消息，不需要窗口是处于顶层。
也就所谓的后台键鼠消息。
以上消息模拟，针对游戏来说大多没用或被检测。很多游戏都用DirectX ，利用DirectInput绕过Windows的消息机制直接和硬件打交道来接收按键信息的。这时候要在模拟键鼠消息就 只有注入游戏进程拦截DirectInput过滤API。比如大漠后台就这样实现的。可惜注入手法太low,基本没戏。因此要模拟Dx游戏键鼠消息只能使用驱动级别的模拟按键。不过驱动按键是全局的 不能像注入DX 过滤那样可以后台。
接下来说说R0/驱动层的模拟按键方式
1. 首先比较老牌的winIO/winR0库.通过PS/2 的0x60,0x64端口发送键鼠消息。可惜只支持老式的P/2圆头鼠标，没有PS/2真实键鼠，系统开机bios识别不到，就不会加载系统的i8042prt.sys;当然也无法模拟了，虚拟机的bios版本是自己的，开机自带i8042prt.sys。但虚拟机只能模拟键盘，不能模拟winIO鼠标。
2. 接下来再说说能兼容PS/2和USB的驱动模拟。
通过系统的kbclass和mouclass还有hidusb定位MouseClassServiceCallback和KeyboardClassServiceCallback。可以通过这两个API call键鼠的结构体发送消息。
驱动公开用最多的也是这种模拟方式。在hidusb设备堆栈底层了，游戏要检测也很容易，作者有次调试某游戏的时候发现TP 在hidusb设备栈低上面几层call了一个检测函数，按键消息拦截进自己进程之后再从KeyboardClassServiceCallback call出来，这检测也是没谁了。怎么突破这类检测，那就hidusb设备栈顶模拟呗。
3,接下来再说说以往论坛少有人提及的按键模拟方式，替换键鼠设备的派遣函数也就hidusb栈顶自上而下模拟按键消息。还有HID真实设备模拟，之前看有小白说什么总线模拟，其实这定义很模糊，瞎扯淡的，反正随意玩，没有模拟不了的。第一次发帖给小伙伴留个福利吧。驱动级的按键消息模拟，没验证的。
```

```
市场上的脚本类型及运行原理：

一，内存类，他的们操作是读取游戏内的基址，偏移，等等找到游戏内的数据，按照数据的返回通过代码实现自动化，可以做到变态，类似于现在的倍攻，秒图瞬移，写出来的脚本也流畅卡点很少，因为内存读到的参数都是准确无误的，所以只要逻辑没有问题，一般都很好。

小编注：大型端游基本用的都是内存脚本。端游挂机最辉煌的时候应该是2010年-2015年左右。这个时间，手游还没火起来，端游工作室很多发了大财。

二，图色脚本，就是所谓的纯脚本，他们是通过找图找色工具控制鼠标键盘来实现自动化，这个就看作者的功底，因为找图找色取到的会有误差，所以脚本出来会有很多卡点，通过自己的逻辑更改来去除卡点，一般也都能正常工作，偶尔会卡死，但是问题不大。

端游时代，除了DNF，基本没人用图色，现在是手游时代，图色还成了香饽饽，真是风水轮流转。

三，脱机，就是类似于不用开客户端，或者开客户端不用进图就把图刷完了，这种是通过协议交互，返回服务器需要的指令，来达到自动化，这种不做太多阐述，因为我也不会。

现在来说说关于这些脚本的运行原理和检测风险：

内存，必须跟游戏一同操作，意思就是必须是一台虚拟机或者物理机，因为他要读取游戏数据，来操作指令，所以关于游戏检测就需要做很多东西，比如攻击游戏的检测，或者注入某个程序来达到给自己加个外套，我前面说的驱动基本就是起到这个作用，所以内存稳不稳定跟你内存用的驱动有很大关系，主要就是能不能过去数据检测。

图色脚本，可以跟游戏一起运行也可以用别的电脑来控制另一台电脑（类似现在的双头），双头就是所谓的隔离，因为游戏不可能检测到你另一台电脑的数据，所以可以完全杜绝检测，但是我说的是杜绝检测，而不是百分之百不封号，因为游戏检测还有一个是行为，行为检测是不管你用没用Wg或者脚本，只要一样连他爸都封。

脱机就不说了，因为没写过。。。。。。。

关于脚本的检测优先级我就不说了，毕竟有同行，也不想档别人的生意。大家仔细看了它们的工作原理基本就知道优先级了。

现在来说说脚本的行为检测：

其实行为检测就是大数据检测，有的脚本写的是定点定技能，有的脚本写的是随机技能，其实这些都是存在一个问题就是你作者出的卡量。你就是在智能的脚本出了几十万或者更多，你在随机也没啥用，因为用的人多，重复数据多，所以被行为就很正常。

所以，无论是散人还是游戏工作室，在选择脚本的时候，一定要了解你用的脚本的原理，游戏公司的检测力度，检测方向，确定你需要哪种东西，别人稳定不代表你也稳定，有很多人已经分享了封号也不一定全是脚本的问题，你也要研究自身的问题。

最后说一句，无论做什么游戏，别头铁，别盲目，如果现在把手里的资本封没了，突然出现了稳定的东西，但是你没有资本你还怎么翻身，不稳就不挂，手里能节省多少算多少，脚本不稳定找别的，别为了几个脚本钱把号达进去，毕竟号要比脚本贵多了。

做游戏工作室，别的我没资格说什么，就脚本而言，我的经验是：别跟风！别跟风！别跟风！还是那句话，别人稳不代表你也能吃肉，了解市场，了解规律，什么都跟比人不一样，你才能稳。

虚拟化
学完以后，你会发现，权限虽然不是直接控制Cpu，但是也比驱动高级，你hook驱动除了要损耗性能过pg，进入三环要进程上下文，还要附加函数，检测太多，用这个，看雪还有一个64位检测全hook的源码，不破虚拟，驱动都干不了你
```

[VT虚拟化技术笔记 - 知乎](https://zhuanlan.zhihu.com/p/489120538)
[Windows 内核安全编程技术实践 - lyshark - 博客园](https://www.cnblogs.com/LyShark/articles/16784393.html)

```
逆向工程中不得不说的优秀开源引擎框架: Capstone, Keystone, Unicorn, Qemu 以及 QiLing 等工具


最近在研究一些用于进行逆向工程的框架：Chain of Fundamental Engines for Reverse Engineering: Capstone, Keystone, Unicorn, Qemu, Qiling。这些工具在某些场合中能够很好的帮助我们进行逆向工作。

汇编与反汇编
Capstone
新加坡南洋理工大学团队在 Blackhat USA 2014 上发布的一个反汇编引擎

笔者将通过一个案例并配合Capstone引擎来实现这个功能，之所以选用该引擎是因为该引擎支持Python包，可以非常容易的与LyScript插件互动，此外Capstone引擎在逆向工程、漏洞分析、恶意代码分析等领域有广泛的应用，著名反汇编调试器IDA则是使用了该引擎工作的。

Capstone 反汇编引擎 官网
项目主页：https://github.com/aquynh/capstone
多平台 Windows、* nix
多架构，例如 Arm、Mips 和 x86
支持 C/Python 接口
Keystone
新加坡南洋理工大学团队在 Blackhat USA 2016 上发布的一个汇编框架

Capstone 汇编框架 官网
项目主页：https://github.com/keystone-engine/keystone
多平台：Windows、* nix
多架构，例如 Arm、Mips 和 x86
支持 C/Python 接口
二进制模拟执行
QEMU
QEMU是一套由Fabrice Bellard所编写的模拟处理器的自由软件，一个通用的系统空间和用户空间仿真器和虚拟机

QEMU 虚拟机 官网
项目主页：https://github.com/qemu/qemu
多平台：Windows、* nix
多架构，例如 Arm、Mips 和 x86
支持 C/Python 接口
Unicorn
新加坡南洋理工大学团队在 Blackhat USA 2015 上发布的轻量级多平台，多体系结构的CPU仿真器框架

Unicorn 引擎 CPU仿真框架 官网
项目主页：https://github.com/unicorn-engine/unicorn
多平台：Windows、* nix
多架构，例如 Arm、Mips 和 x86
支持 C/Python 接口
基于 QEMU

QEMU 提供了一个完整的仿真环境，既可以模拟硬件外设、整个系统，也可以模拟单个二进制程序。而 Unicorn 专注于 CPU 指令的仿真。
QiLing
京东团队在 Defcon 2019 上发布的高级二进制仿真框架

Capstone 二进制仿真框架 官网
项目主页：https://github.com/qilingframework/qiling
多平台：Windows、* nix
多架构，例如 Arm、Mips 和 x86
基于 Unicorn

Qiling 被设计为更高级别的框架，它利用 Unicorn 来模拟 CPU 指令，除此之外，还具有高级分析功能：执行动态检测，甚至可以在运行时热修补代码
总结
上述用于二进制逆向的开源工具，都提供了详细的使用方法，并且有团队一直在维护，对于研究二进制病毒、恶意样本分析大有裨益。例如，

修改固件、二进制，增加或者修改其中的指令，可以使用 Capstone/Keystone 进行汇编指令与二进制的转换
跨平台仿真一些架构的二进制可执行文件， 可以使用 QEMU
二进制指令片段的模拟，可以使用 Unicorn、QiLing
笔者使用过其中的几个，且有想法去集成其中的一些功能，编写一个可视化工具。在这里只是进行简单的介绍，如果感兴趣，还是要实际操作一下。这些工具的官网都给出了使用教程，用起来还是比较简单的。

当然，如果是正常的渗透测试，漏洞挖掘，CTF，这些工具可能用到的场合还是比较受限，因为我们更常用的工具是 IDA、Ghidra、pwntools，他们具有更好的集成性和扩展性，这些工具大家可能更为熟悉，不再赘述。
```

```c
断点都是通过触发程序异常，来达到使程序断下的目的

1.**普通断点**：常规的有使用int 3，还有调试器平时的断点，这2种都为该类型断点，通过执行int 3达到触发异常，让程序断下的目的。但该断点修改了代码段，在反调试中容易被察觉。

2.**条件断点**：在普通断点的基础上，增加限定条件。适用于某一下断处会被多地方调用，则加上限定条件（例：[esp-4]!=某一地址），以达到真正需要断下时触发。

3.**内存断点**：通过修改内存的属性来达到触发异常。可设置触发条件为读、写、执行。但该断点会消耗较大资源，因为内存断点会将目标地址所在的一整个内存页中下断点，当同内存页非下断位置被读、写、访问也会触发，此时调试器会对比数据，看触发的断点位置是否为当初下断处。虽然内存断点的效率经常很不理想，但是因为仅仅是修改了一个内存属性，所以内存断点可以下数量非常多、单断点范围非常大。这是它的优势。

4.**硬件断点**：硬件断点为CPU提供给我们的断点，由4个寄存器（DR0-DR3）存放断点地址，断点属性可设置为读、写、执行，由于寄存器数量有限，只能存在4个硬件断点，这4个断点是否执行由DR7的0、2、4、6位决定，当置为1时，断点生效。

读：当被下断位置**被**执行读取操作后，在执行这个操作的位置断下。 例：a的地址为0x123；在123下读的断点后，0x456 为 if(a==1),则程序会在0x456处断下。

写：当被下断位置**被**执行写操作后，在执行这个操作的位置断下。例：a的地址为0x123；在123下写的断点后，0x456 为a=1,则程序会在0x456处断下。

执行：当运行到下断位置时，在该位置断下。 例：例如0x123456处的代码为c=a+b；在执行到这句时，会在0x123456处断下。

以上断点的地址都在内存中，不能为寄存器。
```


如何寻路时不贴墙，这个很好实现。地图点阵字节集可以表示0-255的值，那么就用0表示通行，255表示不可通行，其他可全部用来表示行走代价。只要在开放列表中，计算g代价时将邻居节点额外乘代价值就可以了。它不仅可以实现不贴墙，还可以根据绕路情况，选择要不要走高代价地区。 你这横平竖直的路径压根就不是a星了。你所谓的优化版，更像是反向优化，完全就是个大bug[笑哭]