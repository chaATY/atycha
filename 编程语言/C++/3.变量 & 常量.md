---
title: 变量 & 常量
date: 2023-12-14 10:17
author: CHA.ATY
environment:
  - vscode_1.78.2
  - gcc_10.3.0
  - C++_14
tags:
  - CPP
---

# 一、变量

变量其实只不过是程序可操作的存储区的名称。

在 C++ 中，有多种变量类型可用于存储不同种类的数据。

C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。

变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。

|类型|描述|
|---|---|
|bool|布尔类型，存储值 true 或 false，占用 1 个字节。|
|char|字符类型，用于存储 ASCII 字符，通常占用 1 个字节。|
|int|整数类型，通常用于存储普通整数，通常占用 4 个字节。|
|float|单精度浮点值，用于存储单精度浮点数。单精度是这样的格式，1 位符号，8 位指数，23 位小数，通常占用4个字节。<br><br>![](3-编程语言/6.%20C++/res/2.png)|
|double|双精度浮点值，用于存储双精度浮点数。双精度是 1 位符号，11 位指数，52 位小数，通常占用 8 个字节。<br><br>![](3-编程语言/6.%20C++/res/3.png)|
|void|表示类型的缺失。|
|wchar_t|宽字符类型，用于存储更大范围的字符，通常占用 2 个或 4 个字节。|

C++ 也允许定义各种其他类型的变量：
1. 整数类型（Integer Types）：
    - `int`：用于表示整数，通常占用4个字节。
    - `short`：用于表示短整数，通常占用2个字节。
    - `long`：用于表示长整数，通常占用4个字节。
    - `long long`：用于表示更长的整数，通常占用8个字节。
2. 浮点类型（Floating-Point Types）：
    - `float`：用于表示单精度浮点数，通常占用4个字节。
    - `double`：用于表示双精度浮点数，通常占用8个字节。
    - `long double`：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。
3. 字符类型（Character Types）：
    - `char`：用于表示字符，通常占用1个字节。
    - `wchar_t`：用于表示宽字符，通常占用2或4个字节。
    - `char16_t`：用于表示16位Unicode字符，占用2个字节。
    - `char32_t`：用于表示32位Unicode字符，占用4个字节。
4. 布尔类型（Boolean Type）：
    - `bool`：用于表示布尔值，只能取`true`或`false`。
5. 枚举类型（Enumeration Types）：
    - `enum`：用于定义一组命名的整数常量。
6. 指针类型（Pointer Types）：
    - `type*`：用于表示指向类型为`type`的对象的指针。
7. 数组类型（Array Types）：
    - `type[]`或`type[size]`：用于表示具有相同类型的元素组成的数组。
8. 结构体类型（Structure Types）：
    - `struct`：用于定义包含多个不同类型成员的结构。
9. 类类型（Class Types）：
    - `class`：用于定义具有属性和方法的自定义类型。
10. 共用体类型（Union Types）：
    - `union`：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型。

- 变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。
- 变量声明：用于向程序表明变量的类型和名字。
- 定义也是声明：当定义变量时我们声明了它的类型和名字。
- extern关键字：通过使用extern关键字声明变量名而不定义它。

---

# 二、变量定义

用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。

变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。
![](编程语言-2-C%20&%20C++/7-C++/res/4.png)

变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：

```cpp
type variable_list;
```
- type 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象
- variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：
```cpp
int    i, j, k;
char   c, ch;
float  f, salary;
double d;
```

变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：
```cpp
type variable_name = value;
```
示例：
```cpp
extern int d = 3, f = 5;    // 声明
int d = 3, f = 5;           // 定义 和 声明
byte z = 22;                // 定义 和 声明
char x = 'x';               // 定义 和 声明
```

不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。

---

# 三、变量声明

声明是用来告诉编译器变量的名称和类型，而不分配内存。

变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

当使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 **extern** 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。

尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的：
```cpp
#include <iostream>
using namespace std;
 
// 变量声明
extern int a, b;
extern int c;
extern float f;
  
int main ()
{
  // 变量定义
  int a, b;
  int c;
  float f;
 
  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c << endl ;
 
  f = 70.0/3.0;
  cout << f << endl ;
 
  return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：
```bash
30
23.3333
```

同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：
```cpp
// 函数声明
int func();
 
int main()
{
    // 函数调用
    int i = func();
}
 
// 函数定义
int func()
{
    return 0;
}
```

---

# 四、左值（Lvalues）和右值（Rvalues）

C++ 中有两种类型的表达式：
- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。

数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。

---

# 五、变量作用域

一般来说有三个地方可以定义变量：
- 在函数或一个代码块内部声明的变量，称为**局部变量**。
- 在函数参数的定义中声明的变量，称为**形式参数**。
- 在所有函数外部声明的变量，称为**全局变量**。

作用域是程序的一个区域，变量的作用域可以分为以下几种：
- **局部作用域**：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。
- **全局作用域**：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。
- **块作用域**：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。
- **类作用域**：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。

**注意：**如果在内部作用域中声明的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部作用域中的变量。

## 局部变量

- 在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。
- 自动变量又称为局部变量/栈区变量，一般习惯称为局部变量
- 局部变量的内存空间是在栈区的，由OS进行申请和释放
- OS不会对未初始化的局部变量设初值，一般是一个随机值
- 局部变量的生命周期(或作用域)在 “{ }” 中，被定义或声明开始，到花括号结束
```cpp
// 局部变量是被auto修饰的(在C++11中auto又有了新的含义，后面专门写一篇文章介绍)
auto int a = 0;
auto float f = 9.7F;
auto double b = 10.8;
```
- 下面的实例使用了局部变量：
```cpp
#include <iostream>
using namespace std;
 
int main ()
{
  // 局部变量声明
  int a, b;
  int c;
 
  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c;
 
  return 0;
}
```

注意：
1. 结构体内的成员变量不是局部变量的意思
2. 函数的形参也是局部变量，函数执行结束，形参的生命周期(或作用域)就结束了，这与for循环等结构中定义的局部变量相似，所以函数不能返回局部变量的地址，函数执行结束，局部变量被释放，返回的地址成为了野指针
3. 不同的作用域内可以定义相同名字的变量，若作用域嵌套，名字相同的变量在小作用域内定义的变量在小作用域内起作用，大作用域内定义的变量在大作用域内起作用，两者没有任何关系
```cpp
void func() {
    int i = 10;
    {
        cout << i << " ";
        int i = 2;
        ++i;
        cout << i << " ";
    }
    cout << i << endl;
}

// 运行结果：10 3 10
```

---

## 全局变量

- 在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。
- 全局变量的值在程序的整个生命周期内都是有效的。
- 外部变量一般习惯称为全局变量，存储类型说明符为extern
- 全局变量一般是定义或者声明在全局位置，也就是 “{ }” 外面
- 全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。
- 全局位置定义或者声明全局变量可以省略 extern，如下面代码中定义的n1、n2和n3三个全局变量(定义全局变量n2时，省略了extern；定义全局变量n3时，省略了extern，且未初始化，系统默认初始化为0)
```cpp
extern int n1 = 10; // 完整的定义一个全局变量
int n2 = 9;         // 省略 extern 存储类型说明符
int n3;             // 省略 extern 存储类型说明符，且未初始化，OS自动初始化为0
void func() {
     cout << n1 << " " << n2 << " " << n3 << endl;
}

// 运行结果：10 9 0
```
- 下面的实例使用了全局变量和局部变量：
```cpp
#include <iostream>
using namespace std;
 
// 全局变量声明
int g;
 
int main ()
{
  // 局部变量声明
  int a, b;
 
  // 实际初始化
  a = 10;
  b = 20;
  g = a + b;
 
  cout << g;
 
  return 0;
}
```
- 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：
```cpp
#include <iostream>
using namespace std;
 
// 全局变量声明
int g = 20;
 
int main ()
{
  // 局部变量声明
  int g = 10;
 
  cout << g;
 
  return 0;
}
//当上面的代码被编译和执行时，它会产生下列结果：`10`
```
- 局部位置声明全局变量，不可以省略存储类型说明符extern，特别需要注意的一点是在局部位置声明全局变量时，不能对全局变量进行初始化操作
```cpp
// ====== 测试 ======
// file: a.cpp
#include <iostream>
using namespace std;

void func() {
    extern int n;
    cout << n << endl;
}

// file: b.cpp
#include <iostream>
using namespace std;

int n = 9;
void func();

int main() {
    func();
    system("pause");
    return 0;
}

// 运行结果：9
```
- 在多文件编程中，使用其他文件中定义的全局变量需要加上存储类型说明符 extern
```cpp
// ====== 测试 ======
// file: a.cpp
#include <iostream>
using namespace std;
extern int n;
void func() {
    cout << n << endl;
}

// file: b.cpp
#include <iostream>
using namespace std;

int n = 9;
void func();

int main() {
    func();
    system("pause");
    return 0;
}

// 运行结果：9
```

---

## 初始化局部变量和全局变量

当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：

|数据类型|初始化默认值|
|---|---|
|int|0|
|char|'\0'|
|float|0|
|double|0|
|pointer|NULL|

块作用域指的是在代码块内部声明的变量：
```cpp
#include <iostream>

int main() {
    int a = 10;
    {
        int a = 20;  // 块作用域变量
        std::cout << "块变量: " << a << std::endl;
    }
    std::cout << "外部变量: " << a << std::endl;
    return 0;
}
```

以上实例中，内部的代码块中声明了一个名为 a 的变量，它与外部作用域中的变量 a 同名。内部作用域中的变量 a 将覆盖外部作用域中的变量 a，在内部作用域中访问 a 时输出的是20，而在外部作用域中访问 a 时输出的是 10。

当上面的代码被编译和执行时，它会产生下列结果：
```bash
块变量: 20
外部变量: 10
```

---

## 类作用域

类作用域指的是在类内部声明的变量：
```cpp
#include <iostream>

class MyClass {
public:
    static int class_var;  // 类作用域变量
};

int MyClass::class_var = 30;

int main() {
    std::cout << "类变量: " << MyClass::class_var << std::endl;
    return 0;
}
```

以上实例中，MyClass 类中声明了一个名为 class_var 的类作用域变量。

可以使用类名和作用域解析运算符 `::` 来访问这个变量。在 main() 函数中访问 class_var 时输出的是 30。

---

# 六、常量

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。

常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。

常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

## 整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：
- 0x 或 0X 表示十六进制
- 0 表示八进制
- 不带前缀则默认表示十进制。
- 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。
- 实例：
```cpp
212         // 合法的
215u        // 合法的
0xFeeL      // 合法的
078         // 非法的：8 不是八进制的数字
032UU       // 非法的：不能重复后缀
85         // 十进制
0213       // 八进制 
0x4b       // 十六进制 
30         // 整数 
30u        // 无符号整数 
30l        // 长整数 
30ul       // 无符号长整数
```

## 浮点常量
浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

实例：
```cpp
3.14159       // 合法的 
314159E-5L    // 合法的 
510E          // 非法的：不完整的指数
210f          // 非法的：没有小数或指数
.e55          // 非法的：缺少整数或分数
```

## 布尔常量
布尔常量共有两个，它们都是标准的 C++ 关键字：
- **true** 值代表真。
- **false** 值代表假。

我们不应把 true 的值看成 1，把 false 的值看成 0。

## 字符常量

字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 **char** 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：
|转义序列|含义|
|---|---|
|\\|\ 字符|
|\'|' 字符|
|\"|" 字符|
|\?|? 字符|
|\a|警报铃声|
|\b|退格键|
|\f|换页符|
|\n|换行符|
|\r|回车|
|\t|水平制表符|
|\v|垂直制表符|
|\ooo|一到三位的八进制数|
|\xhh . . .|一个或多个数字的十六进制数|

下面的实例显示了一些转义序列字符：
```cpp
#include <iostream>
using namespace std;
 
int main()
{
   cout << "Hello\tWorld\n\n";
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：
```bash
Hello   World
```

## 字符串常量

字符串字面值或常量是括在双引号 "" 中的。

一个字符串包含类似于字符常量的字符：
- 普通的字符
- 转义序列
- 通用的字符

您可以使用 \ 做分隔符，把一个很长的字符串常量进行分行。

下面的实例显示了一些字符串常量：
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string greeting = "hello, runoob";
    cout << greeting;
    cout << "\n";     // 换行符
    string greeting2 = "hello, \
                        runoob";
    cout << greeting2;
    return 0;
}
```
```bash
hello, runoob
hello, runoob
```

---

# 七、常量定义

在 C++ 中，有两种简单的定义常量的方式：
- 使用 **#define** 预处理器。
- 使用 **const** 关键字。

## `#define` 预处理器

下面是使用 `#define` 预处理器定义常量的形式：
```cpp
#define identifier value
```

具体请看下面的实例：
```cpp
#include <iostream>
using namespace std;
 
#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'
 
int main()
{
 
   int area;  
   
   area = LENGTH * WIDTH;
   cout << area;
   cout << NEWLINE;
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：`50`

## const 关键字

您可以使用 **const** 前缀声明指定类型的常量，如下所示：
```cpp
const type variable = value;
```

具体请看下面的实例：
```cpp
#include <iostream>
using namespace std;
 
int main()
{
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   cout << area;
   cout << NEWLINE;
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：`50`