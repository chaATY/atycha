---
title: 全局变量和局部变量
date: 2023-11-14 15:40
author: CHA.ATY
tags:
  - C
  - Windows
---

![](https://img.shields.io/badge/C-17-green.svg)
![](https://img.shields.io/badge/visual_studio-2019-green.svg)
![](https://img.shields.io/badge/Windows10-22H2_19045.3570-green.svg)

# 一、前言

每个变量都有属于它的作用域，就是这些变量在什么范围内有效。按照变量的作用域范围可以把变量划分为局部变量和全局变量。

内存区域：
|||
区域	功能	区域属性
代码区	存储程序要执行的代码	可读可执行
堆栈	存储参数、局部变量、临时数据	操作系统分配
堆	动态申请的、大小可变的	可读可写
全局变量区	存储全局变量	可读可写
常量区	存储常量	只读

---

# 二、全局变量

一个源文件中可以包含若干个函数，在函数外部定义的变量就是全局变量或外部变量：
- 外部变量一般习惯称为全局变量，存储类型说明符为extern
- 全局变量一般是定义或者声明在全局位置，也就是 “{ }” 外面
- 全局位置定义或者声明全局变量可以省略extern，如下面代码中定义的n1、n2和n3三个全局变量(定义全局变量n2时，省略了extern；定义全局变量n3时，省略了extern，且未初始化，系统默认初始化为0)
```c
extern int n1 = 10; // 完整的定义一个全局变量
int n2 = 9;         // 省略 extern 存储类型说明符
int n3;             // 省略 extern 存储类型说明符，且未初始化，OS自动初始化为0
void func() {
     cout << n1 << " " << n2 << " " << n3 << endl;
}

// 运行结果：10 9 0
```

全局变量为该源文件中所有函数所共有，它的作用范围是从变量定义的位置到源文件结束。
- 全局变量在程序编译完成后地址就已经确定下来了，只要程序启动，全局变量就已经存在了，启动后里面是否有值取决于声明时是否给定了初始值，如果没有，默认为0
- 全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值.
- 全局变量所占内存会一直存在，直到整个进程结束.
- 全局变量的反汇编识别：
```asm
MOV  寄存器,byte/word/dword ptr ds:[0x12345678]
//上面的0x12345678是固定的地址，每次程序启动都不变
//通过寄存器的宽度，或者byte/word/dword  来判断全局变量的宽度
```
- 全局变量就是所谓的基址

注意：不同c文件中的同名全局变量：
- 果在不同的c文件中定义了同名的全局变量，则它们会占用相同的内存空间，而且编译链接时不会报错！
- 如下两个文件：
```c
#include <stdio.h>
float g;
void a(void);
int main(void)
{
    g = 3.14;
    printf("%f\n", g);
    a();
    printf("%f\n", g);
    printf("%08lx\n", (unsigned long)&g);
    return 0;
}
```
```c
#include <stdio.h>
int g;
void a(void)
{
    g = 12345;
    printf("%08lx\n", (unsigned long)&g);
}
```
用gcc加-Wall后编译链接，无任何warning。运行结果：
```text
3.140000
00405050
0.000000
00405050
```
- 解决办法也简单，前面加上static，限定只能在本文件内使用即可。

---

# 三、局部变量

局部变量出现在三种地方：
1. 在函数的开头定义的变量
2. 在函数内的复合语句内定义的变量
3. 形式参数

- 局部变量在程序编译完成后并没有分配固定的地址
- 在所属的方法没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存
- 当局部变量所属的方法执行完毕后，局部变量所占用的内存将变成垃圾数据.局部变量消失
- 局部变量只能在方法内部使用，函数A无法使用函数B的局部变量
- 局部变量的反汇编识别
```asm
[ebp-4]

[ebp-8]

[ebp-0xC]
```

---

# 四、示例

```c
#include "stdafx.h"
//全局变量
int global=0x610;
int main(int argc, char* argv[])
{
    //局部变量
        int temp=0x160;

        global=global+temp;

        return 0;
}
```
```asm
4:    #include "stdafx.h"
5:    //全局变量
6:    int global=0x610;
7:    int main(int argc, char* argv[])
8:    {
00401010   push        ebp
00401011   mov         ebp,esp
00401013   sub         esp,44h
00401016   push        ebx
00401017   push        esi
00401018   push        edi
00401019   lea         edi,[ebp-44h]
0040101C   mov         ecx,11h
00401021   mov         eax,0CCCCCCCCh
00401026   rep stos    dword ptr [edi]
9:        //局部变量
10:       int temp=0x160;
00401028   mov         dword ptr [ebp-4],160h
11:
12:       global=global+temp;
0040102F   mov         eax,[global (00428a64)]
00401034   add         eax,dword ptr [ebp-4]
00401037   mov         [global (00428a64)],eax
13:
14:       return 0;
0040103C   xor         eax,eax
15:   }
0040103E   pop         edi
0040103F   pop         esi
00401040   pop         ebx
00401041   mov         esp,ebp
00401043   pop         ebp
00401044   ret
```
我们可以看到相关代码在这里：
```asm
9:        //局部变量
10:       int temp=0x160;
00401028   mov         dword ptr [ebp-4],160h
11:
12:       global=global+temp;
0040102F   mov         eax,[global (00428a64)]
00401034   add         eax,dword ptr [ebp-4]
00401037   mov         [global (00428a64)],eax
```
我们可以很清楚地看到局部变量是直接保存在`[ebp-4]`也就是堆栈中的

而全局变量则是保存在一个固定的内存地址00428a64里

同时在断点刚断下的时候，就是还没运行上面的代码时，观察[global (00428a64)]也就是全局变量地址里存储的内容时，可以看到
![](3-编程语言/5.%20C/res/11.png)

我们全局变量已经初始化并被赋值了，观察整个main函数的反汇编代码，我们并没有看到全局变量赋值相关的语句，但这并不能说明程序在运行前就已经赋值了，别忘了也有可能是在mainCRTStartup中将这里初始化的，为了印证这一点，我们直接将程序用OD打开，然后会在mainCRTStartup函数执行前断下，以此来验证是否是一打开程序全局变量就已经初始化了

输入之前全局变量的地址，然后查看
![](3-编程语言/5.%20C/res/12.png)
![](3-编程语言/5.%20C/res/13.png)

可以观察到左下角数据窗口里，我们的全局变量已经初始化了，验证完毕(●ˇ∀ˇ●)

---

> 版权声明©：
>
> 本文为 CHA.ATY 的原创文章，遵循 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/) 许可证进行授权，转载请附上原文出处链接及本声明。
>
> 作者：CHA.ATY
>
> 邮箱：2165150141@qq.com