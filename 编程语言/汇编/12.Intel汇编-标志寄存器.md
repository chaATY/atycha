---
title: Intel汇编-标志寄存器
date: 2023-11-07 17:21
author: CHA.ATY
environment:
  - Windows10-22H2_19045.3570
tags:
  - Intel汇编
---

# 一、前言

标志寄存器 EFLAGS 是实现条件判断和逻辑判断的一种机制，在汇编语言中一般不直接访问 EFLAGS 寄存器，而是通过指令的操作隐含访问 EFLAGS 寄存器，下面是一个利用 EFLAGS 寄存器的例子：

```x86asm
Cmp dword ptr [ebp+8],0    ;影响标志CF、ZF、SF、OF、AF和PF
Jz 00405898               ; 如果ZF等于1，则跳转到00405898
```

标志寄存器 EFLAGS 一共有 32 位，在这 32 位中大部分是保留和给编写操作系统的人用的，一般情况下只需知道 32 位的低 16 位中的 8 位即可，如下表：

|31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|0|0|0|0|0|0|0|0|0|0|ID|VIP|VIF|AC|VM|RF|0|NT|IOPL|OF|DF|IF|TF|SF|ZF|0|AF|0|PF|1|CF|

EFLAGS 寄存器包含3类标志：
1. 用户报告算术指令(如ADD、SUB、MUL、DIV等)结果的状态标志(CF、PF、AF、ZF、SF、OF)。
2. 控制字符串指令操作方向的控制标志(DF)
3. 共系统软件执行的管理操作的系统标志。

|寄存器|位|主要用途|
|---|---|---|
|CF (Carry Flag)| 0 |进位标志，进位时置1，否则置0|
|PF (Parity Flag)| 2 |奇偶标志。结果操作数中1的个数为偶数时置1，否则置0|
|AF (Auxiliary carry Flag)| 4 |辅助进位标志，有进位时置1，否则置0|
|ZF (Zero Flag)| 6 |零标志，运算结构为0时ZF位位置1，否则置0|
|SF (Sign Flag)| 7 |符号标志，结果为负时置1，否则置0|
|TF| 8 |单步标志|
|IF (Interrupt Flag)| 9 |中断标志|
|DF (Direction Flag)| 10 |方向标志，表示DI以及SI自增（减）的偏移地址寄存器的自增（减）方向，在串处理指令中控制信息的方向|
|OF (Overflow Flag)| 11 |溢出标志，溢出时为1，否则置0|
| IOPL(I/O Privilege Level) | 12和13 | 用于表示当前任务(程序)的I/O权限级别 |
| NT(Nested Task flag) | 14 | 任务嵌套标志，为1时表示当前任务是链接到前面执行的任务的，通常是由于中断或异常触发了IDT表中的任务门 |
| RF(Resume Flag) | 16 | 控制处理器对调试异常(#DB)的响应，为1时暂时禁止由于指令断点(是通过调试寄存器设置的指令断点)导致的调试异常 |
| VM(Virtual-8086 Mode flag) | 17 | 为1时启用虚拟8086模式，清除该位返回到普通的保护模式 |
| AC(Alignment Check flag) | 18 | 设置此标志和CR0的AM标志可以启用内存对齐检测 |
| VIF(Virtual Interrupt Flag) | 19 | 与VIP标志一起用于实现奔腾处理器引入的虚拟中断机制 |
| VIP(Virtual Interrupt Pending flag) | 20 | 与VIF标志一起用于实现奔腾处理器引入的虚拟机中断机制 |
| ID(Identification flag) | 21 | 用于检测是否支持CPUID指令，如果能够成功设置和清除该标志，则支持CPUID指令 |

STC、CLC设置和清除CF位。

STD、CLD设置和清除DF位。

STI、CLI 设置和清除IF位(有权限要求)。

---

# 二、CF

如果运算结果的**最高位**产生了一个进位或借位，那么，其值为1，否则其值为0，示例如下：
```x86asm
0x80+0x40：
	0x80:0 1000 0000
	0x40:0 0100 0000
	
	// 最高位并没有发生变化，于是CF位为0
	0x80 + 0x40 = 1100 0000
0x80-0x40：
	// 注意这里借位的位是**1**000 0000中的加*部分，而非**0** 1000 0000这里的最高位
	// 最高位并没有发生变化，于是CF位为0
	0x80 - 0x40 = 0100 0000
0x80-0x81：
	// 最高位被借位，于是CF位为1
	0x80 - 0x81 = 1111 1111 = -1（十进制）
```

---

# 三、PF

奇偶标志PF用于反映运算结果中**最低有效字节**中“1”的个数的奇偶性，如果“1”的个数为偶数，则PF的值为1，否则其值为0。
```x86asm
// 0x803: 0000 1000 0000 0011

MOV AX,803 ADD AX,1

// 执行结果
// 0x804: 0000 1000 0000 0100        总共2个1 ,PF应为1，但实际运行结果PF为0
// 因为PF是根据最低有效字节来看，即8**04**后面04的这部分
// 04： 0000 0100 总共1个1，所以PF为0
```

---

# 四、AF
在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：
- 在字操作时，发生低字节向高字节进位或借位时
- 在字节操作时，发生低4位向高4位进位或借位时

AF与**数据宽度**相关：
- 32位时 FFFF **F** FFF
- 16位时 FF **F** F
- 8位时 F **F**

加黑的字体为AF标志位判断的位置，如果该位置要向前进位则AF为1，否则为0，和CF相似，不过判断的位置不同

---

# 五、ZF

零标志ZF用来反映运算结果是否为0

如果运算结果为0，则其值为1，否则其值为0

作用：在判断**运算结果**是否为0时，可使用此标志位

```x86asm
// 通过xor将eax清零，会改变zf标志位为1
XOR EAX,EAX
// 通过MOV将EAX赋值为0，非**运算**，不改变zf标志位
MOV EAX,0
```

---

# 六、SF

符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同

---

# 七、OF

溢出标志OF用于反映有符号数加减运算所得结果是否溢出

**注意与CF区分**！！！

最高位进位与溢出的区别：

进位标志表示**无符号数**运算结果是否超出范围.

溢出标志表示**有符号数**运算结果是否超出范围.

溢出主要是给**有符号运算**使用的，在有符号的运算中，有如下的规律：

- 正 + 正 = 正  如果结果是负数，则说明有溢出
- 负 + 负 = 负  如果结果是正数，则说明有溢出
- 正 + 负 永远都不会有溢出

---

# 八、DF

DF：方向标志位

DF=1时串操作为减地址方式 DF=0为增地址方式

下面的MOVS指令有说明DF的具体应用

[相关汇编指令](https://www.52pojie.cn/thread-1379580-1-1.html#37113239_%E7%9B%B8%E5%85%B3%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4)

---

> 版权声明©：
>
> 本文为 CHA.ATY 的原创文章，遵循 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/) 许可证进行授权，转载请附上原文出处链接及本声明。
>
> 作者：CHA.ATY
>
> 邮箱：2165150141@qq.com