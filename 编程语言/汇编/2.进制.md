---
title: 进制
date: 2023-11-13 10:40
author: CHA.ATY
tags:
  - Intel汇编
---

![](https://img.shields.io/badge/Intel-x86-green.svg)
![](https://img.shields.io/badge/Windows10-22H2_19045.3570-green.svg)

# 一、前言

进制计算与内存宽度是计算机中基础知识，也是计算机中基本计算逻辑。

---

# 二、进制

- 十进制的定义：由十个符号组成，分别是0 1 2 3 4 5 6 7 8 9 逢十进一
- 九进制的定义：由九个符号组成，分别是0 1 2 3 4 5 6 7 8 逢九进一
- 十六进制的定义：由十六个符号组成，分别是0 1 2 3 4 5 6 7 8 9 A B C D E F
- N进制的定义：由N个符号组成 逢N进一

进制的本质：N进制的定义实则为由N个符号组成，逢N进位。这里的符号不一定要是 0 1 2 3 4 ....。也可以自定义为R T Y U I O 等其它符号

自定义进制的符号可以作为一种加密的手段，给解密者带来麻烦。

在内存中的数据采用十六进制数表示。每个二进制数表示 1 位，1 字节在内存中占 8 位。

因为 F 需要 4 个二进制 1111 表示，所以 1 个十六进制数要用 4 个二进制数表示，所以 1 字节由 2 个十六进制数组成。进制对比如下：

| 二进制 | 十六进制 | 十进制 |
| :----: | :------: | :----: |
|  0000  |    0    |   0   |
|  0001  |    1    |   1   |
|  0010  |    2    |   2   |
|  0011  |    3    |   3   |
|  0100  |    4    |   4   |
|  0101  |    5    |   5   |
|  0110  |    6    |   6   |
|  0111  |    7    |   7   |
|  1000  |    8    |   8   |
|  1001  |    9    |   9   |
|  1010  |    A    |   10   |
|  1011  |    B    |   11   |
|  1100  |    C    |   12   |
|  1101  |    D    |   13   |
|  1110  |    E    |   14   |
|  1111  |    F    |   15   |

---

# 三、内存宽度

数学上的数字是没有大小限制的，可以无限大。但在计算机中，由于硬件的制约，数据是有长度限制的，超过数据宽度的数据会被丢弃。

同一个数据，表示无符号数和有符号数则其含义不同。
- 无符号数：正数
- 有符号数：正数、负数

当数据宽度为4时，即数据只能存储4位2进制位0000~1111。

在计算机中，存储的最小单位是位，存储数据的最小单位是字节，内存最小单位也是字节。

---

# 四、运算

计算机中只做加法运算，根据内存宽度，如果计算结果超出范围则获取满足内存宽度的低位作为结果值。

## 原码、反码和补码

* 正数：原码、反码和补码都相同
* 0的补码：数0的补码表示是唯一的。
  * [+0]补 = [+0]反 = [+0]原 = 00000000
  * [ -0]补 = 11111111 + 1 = 00000000
* 负数：负数原码和补码的相互转换规则是，符号位不变，数值位按位取反，末位再加1，也就是 x(补) = x(反)+1。
  * 例如：求 -5 的补码。-5 对应带符号位负数 5（10000101）→ 除符号位外所有位取反（11111010）→ 加 00000001 为 (11111011) 所以 -5 的补码是 11111011。

## 整数

有符号整数中用来表示符号的是最高位，即符号位。

* 最高位为 0 表示正数
* 最高位为 1 表示负数

有符号整数 int 在内存中同样占 4 字节，但由于最高位为符号位，不能用来表示数值，因此有符号整数的取值范围要比无符号整数取值范围少 1 位，如下表：

|     进制     |         取值范围         |
| :-----------: | :----------------------: |
|   十六进制   | 0x80000000 ~ 0x7FFFFFFF |
|    十进制    | -2147483648 ~ 2147483647 |
| 十六进制 正数 | 0x00000000 ~ 0x7FFFFFFF |
| 十六进制 负数 | 0x80000000 ~ 0xFFFFFFFF |

负数在内存中都是以[补码](https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81)形式存放的

减法运算：

* 几乎所有的编程语言中有符号整数都是以补码形式存储的，这是因为计算机只会做加法，所以需要把减法转换为加法。
* 例如：（3-2）可转换成（3+（-2）），运算过程为 3 的十六进制原码 0x00000003 加上 -2 的十六进制补码 0xFFFFFFFE，从而得到 0x100000001。由于存储范围为4字节大小，两数相加后产生了进位，超出了存储范围，超出的 1 将被舍弃。进位被舍弃后，结果为 0x00000001。

**注意**：对于 4 字节**补码**，0x80000000 所表达的意义可以是负数 0，也可以是 0x80000001 减去 1。因为0的正负值是相等的，没有必要再用负数 0 ，所以就把这个值的意义规定为0x80000001 减 1，这样 0x80000000 也就成为 4 字节负数的最小值了。这也是有符号整数的取值范围中，负数区间总是比正数区间多一个最小值的原因。

```html
0x80000000(补) -> 0x80000000(原码) 表示 -0
0x00000000(补) -> 0x00000000(原码) 表示 0
0x80000001(补) -> 0x7FFFFFFF(原码) 表示 -2147483647
因为 -0 与 0 相同因此 0x80000000 表示 -0 没有意义了，所以用 0x80000000 表示 -2147483648 也就是int中最小值
```
[CPU如何计算2+3?](https://www.52pojie.cn/thread-1379249-1-1.html#37101150_cpu%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%972+3?)

## 浮点数

整型类型是将十进制转换成二进制保存在内存中，以十六进制方式显示。

浮点类型是将浮点小数转换成的二进制码重新编码，再进行存储。C/C++ 的浮点数是有符号的。

浮点数编码转换采用的是 IEEE 规定的编码标准，float 和 double 这两种类型数据的转换原理相同，但由于表示的范围不一样，编码方式有些许区别。

IEEE 规定的浮点数编码会将一个浮点数转换为二进制数。以科学记数法划分，将浮点数拆分为 3 部分：
* 符号
* 指数
* 尾数

例如C语言的float 类型在内存中占 4 字节（32 位）。最高位用于表示符号，在剩余的 31 位中，从左向右取 8 位表示指数，其余表示尾数。

在进行二进制转换前，需要对单精度浮点数进行科学记数法转换。

转化步骤：
* 进制转化：先把浮点数分别把整数部分和小数部分转换成 2 进制
  * 整数部分用除2取余的方法
  * 小数部分用乘2取整的方法
* 使用科学记数法
* 符号位：正数是 0，负数是 1
* 指数位：指数位要加 127，这是因为指数可能出现负数，十进制数 127 可表示为二进制数 01111111，IEEE 编码方式规定，当指数小于 0111111 时为一个负数，反之为正数，因此 01111111 为 0
* 尾数位：尾数位中最高位 1 是固定值，忽略不计，转换回十进制数时需要 1 即可。

示例：12.25f 转换为 IEEE 编码
* 进制转化：将 12.25f 转换成对应的二进制数 1100.01
* 使用科学记数法：1.10001 * 10^3
* 符号位：0
* 指数位：十进制 3+127=130，转换为二进制为 10000010
* 尾数位：10001 000000000000000000（当不足23位时，低位补0填充）
* 结果：01000001010001000000000000000000

示例负数：-0.125f 转换为 IEEE 编码
* 进制转化：将 -0.125f 转换成对应的二进制数 0.001
* 使用科学记数法：1.0 * 10^-3
* 符号位：1
* 指数位：十进制 -3+127=124，转换为二进制是01111100，如果不足8位，则高位补0
* 尾数位：00000000000000000000000
* 结果：10111110000000000000000000000000

上面的两个示例浮点数小数部分转换为二进制时都是有穷的，如果小数部分转换为二进制时得到一个无穷值，则会根据尾数部分的长度舍弃多余的部分。如单精度浮点数1.3f，小数部分转换为二进制就会产生无穷值，依次转换为0.3、0.6、1.2、0.4、0.8、1.6、1.2、0.4、0.8......转 换 后 得 到 的 二 进 制 数 为1.01001100110011001100110，到第23位终止，尾数部分无法保存更大的值。所以进行IEEE编码转换后得到的是一个近似值，存在一定的误差。再次将这个IEEE编码值转换成十进制小数，得到的值为1.2516582，四舍五入保留一位小数之后为1.3。这就解释了为什么C++在比较浮点数值是否为0时，要做一个区间比较而不是直接进行等值比较。

---

# 五、逻辑运算

* 或运算（or |）
	* 只要有一个为1则结果为1
* 与运算（and &）
	* 两个都是1结果才为1
* 异或运算（xor ^）
	* 相同为0 不同为1
* 非运算(not !)
	* 取反 1是0 0是1

---

> 版权声明©：
>
> 本文为 CHA.ATY 的原创文章，遵循 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/) 许可证进行授权，转载请附上原文出处链接及本声明。
>
> 作者：CHA.ATY
>
> 邮箱：2165150141@qq.com