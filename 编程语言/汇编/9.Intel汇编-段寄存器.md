---
title: Intel汇编-段寄存器
date: 2023-11-07 19:10
author: CHA.ATY
environment:
  - Windows10-22H2_19045.3570
tags:
  - Intel汇编
---

# 一、前言

段寄存器有ES、CS、SS、DS、FS、GS、LDTR、TR共8个：

- ES：扩展段。在串操作时(比如cmovs)目标操作数的基址是ES，源操作数是DS。
- CS：代码段，配合EIP使用。
- SS: 堆栈段，凡是基址是EBP或ESP的，段前缀就是SS。
- DS：数据段，默认的都是DS。
- FS、GS：80386 之后定义的。

---

# 二、段寄存器结构：

结构图如下：
```html
|---------------------------------------|
|   不可见部分    可见部分                 |
|       |           |                   |
|   _____________  __                   |
|  /             \/  \                  |
|  -------------------                  |
|  |     |     |  |  |                  |
|  |     |     |  |  | <- 16位Selecter  |
|  -------------------                  |
|     ^     ^    ^                      |
|     |     |    |                      |
|32位Base  32位  16位Attribute           |
|         Limit                         |
|---------------------------------------|
```


段寄存器的大小是 96 位，段寄存器结构可以抽象成以下结构：
```c
struct Segment
{
  WORD Selector;  //16位段选择子，可见部分.  使用OD 或者X64dbg看段寄存器只会显示16位的段选择子可见部分.当读段寄存器(如mov ax,CS)的时候，只会返回这16位。或者push seg 操作针对的都是这16位。如果目标操作数是32位(如mov eax ,CS),则将16位零扩展成32位赋给目标操作数。但是写的时候，就会涉及到96位
  WORD Attribute; //16位表示的段属性, 表示了当前段寄存器是可读的可写的还是可执行的
  DWORD Base;     //32位表示的基址,表示段从哪里开始
  DWORD limit;    //32位表示,表示的是基址的长度. base + limit 可以确定一个段的大小
}
```

在x86下可以看如下寄存器表示图：

| 寄存器名称 | 段选择子(Select) | 段属性(Attributes) | 段基址(Base) | 段长(Limit) | 
| --- | --- | --- | --- | --- | 
| ES(附加扩展段) | 0x0023 | 可读，可写 | 0x00000000 | 0xFFFFFFFF | 
| CS(代码段) | 0x001B | 可读，可写 | 0x00000000 | 0xFFFFFFFF | 
| SS(堆栈段) | 0x0023 | 可读，可写 | 0x00000000 | 0xFFFFFFFF | 
| DS(数据段) | 0x0023 | 可读，可写 | 0x00000000 | 0xFFFFFFFF | 
| FS(分段机制) | 0x003B | 可读，可写 | 0x7FFDF000 | 0xFFF | 
| GS | 未使用 | 未使用 | 未使用 | 未使用 | 

---

# 三、段寄存器读写

可以使用 MOV 指令对段寄存器进行读写。

读操作时，可以读到段寄存器的段选择子部分的16位。例如 mov ax,es 指令会把es寄存器的段选择子读到ax。

写操作时，会写入96位，其中源操作数的16位写入到段寄存器的段选择子部分，另外80位会根据段选择子从GDT表（全局描述表）中获取。因此，
```asm
mov ax,cs
mov ds,ax
```
实际上是把 cs 完整的复制给了 ds。

---

# 四、段属性探测

**CS代码段属性探测**
```c
int Var = 0;
int main()
{  
    __asm   
    {      
        mov ax,cs      
        mov ds,ax       
        mov dword ptr ds:[Var],eax         ;等价于 mov dword ptr cs:[Var],eax  
    }
}
```
将 CS 赋值到AX中，AX赋值给DS。此时DS就代表 CS 了。如果以把 eax 值给 CS 则会出现错误。说明权限确实是不可写。

**其它代码段段属性探测**
```c
int Var = 0; int main()
{   
    __asm   
    {       
        mov ax,ss
        mov ds,ax       
        mov dword ptr ds:[Var],eax   
    }
}
```

**段基地址探测**

通常我们用汇编读写某一个地址时，如下：`Mov dword ptr ds:[0x123846],eax`

这时我们把 eax 的值往地址去写，写的地址是：`ds.base + 0x123456`

```c
int main()
{
    __asm
    {
        mov ax,fs
        mov gs,ax
        mov eax,gs:[0]
    }
}
```

**段长探测**

在段地址探测中,访问有效地址等价于段.base + 偏移地址

```c
int main()
{
    __asm
    {
        mov ax, fs
        mov gs, ax
        mov eax, gs: [0]  //fs.base + 0 读取
        mov eax,gs:[0x1000]//fs.base + 0x1000
        mov eax, dword ptr ds : [eax + 0xFFF] ;
       // mov eax,gs:[0x1000] //fs.base + 0x1000 读取
    }
}
```

---

# 五、段描述符与段选择子

段寄存器有 96位，其中 80位 不可见，包括 Base，limit，attribute。16位可见，即段选择子 selector。

对段寄存器进行写入时，CPU 根据段选择子到 GDT 表中寻找段描述符，段描述符共 8字节，64位，CPU 根据段描述符填充段寄存器。

那么问题就是，如何用64位的段描述符来填充80位的段寄存器呢？为了解决该问题，这就需要段描述符的P，G位。

---

# 六、字段和标志位

![](编程语言-1-汇编/res/9.png)
Limit
  段限长字段Limit（Segment limit field）：用于指定段的长度。处理器会把段描述符中两个段限长字段组合成一个20位的值，并根据颗粒度标志G来指定段限长Limit值的实际含义。
  • 如果G=0，则段长度Limit范围可从1B～1MB，单位是1B。
  • 如果G=1，则段长度Limit范围可从4KB～4GB，单位是4KB。

  根据段类型中的段扩展方向标志E，处理器以两种不同方式使用段限长Limit：
  • 对于向上扩展的段（expand-up segment，简称上扩段），逻辑地址中的偏移值范围可以从0到段限长值Limit。大于段限长Limit的偏移值将产生一般保护性异常（general-protection exceptions, #GP, SS段寄存器除外）或产生栈错误异常（stack-fault exceptions, #SS）。
  • 对于向下扩展的段（expand-down segment，简称下扩段），段限长Limit的含义相反。根据默认栈指针大小标志B的设置，偏移值范围可从段限长Limit+1到0xFFFFFFFF或0xFFFF。而小于等于段限长Limit的偏移值将产生一般保护性异常或栈错误异常。对于下扩段，减小段限长字段中的值会在该段地址空间底部分配新的内存，而不是在顶部分配。IA-32架构的栈总是向下扩展的，因此这种实现方式很适合扩展堆栈。

Base
  基地址字段Base（Base address field）：该字段定义在4GB 线性地址空间中一个段字节0所处的位置。处理器会把3个分立的基地址字段组合形成一个32位的值。段基地址应该对齐16字节边界。16字节对齐不是必须的，但对齐在16字节边界上使得程序能最大化程序性能。


TYPE
  段类型字段TYPE（Type field）：指定段或门（Gate）的类型、说明段的访问类型以及段的扩展方向。该字段的解释依赖于描述符类型标志S指明是一个应用（存储段）描述符还是一个系统描述符（System）。TYPE字段的编码对代码、数据或系统描述符都不同。

S
  描述符类型标志S（Descriptor type flag）：用于指明一个段描述符是系统段描述符（当S=0）还是代码 或数据段 描述符（当S=1）。

DPL
  描述符特权级字段DPL（Descriptor privilege level）：用于指明描述符的特权级。特权级范围从0到3。0级特权级最高，3级最低。DPL用于控制对段的访问。

P
  段存在标志P（Segment present）：用于指出一个段是在内存中（P=1）还是不在内存中（P=0）。
  当一个段描述符的P标志为0时，那么把指向这个段描述符的选择符加载进段寄存器将导致产生一个段不存在异常（segment-not-present exception，#NP）。内存管理软件可以使用这个标志来控制在某一给定时间实际需要把那个段加载进内存中。这个功能为虚拟存储提供了除分页机制以外的控制。当P标志为0时，操作系统可以自由使用格式中标注为可用（Available）的字段位置来保存自己的数据，例如有关不存在段实际在什么地方的信息。
D/B标志
  D/B标志（默认操作大小/默认栈指针大小和/或上界限，Default operation size/default stack pointer size and/or upper bound）：根据段描述符描述的是一个可执行代码段、下扩数据段还是一个堆栈段，这个标志具有不同的功能。（对于32位代码和数据段，这个标志应该总是设置为1；对于16位代码和数据段，这个标志被设置为0。）
  • 可执行代码段。此时这个标志称为D标志并用于指出该段中的指令引用有效地址和操作数的默认长度。如果该标志置位，则默认值是32位地址和32位或8位的操作数；如果该标志为0，则默认值是16位地址和16位或8位的操作数。指令前缀0x66可以用来选择非默认值的操作数大小；前缀0x67可用来选择非默认值的地址大小。
  • 栈段（由SS寄存器指向的数据段）。此时该标志称为B（Big）标志，用于指明隐含堆栈操作（如PUSH、POP或CALL）时的栈指针大小。如果该标志置位，则使用32位栈指针并存放在ESP寄存器中；如果该标志为0，则使用16位栈指针并存放在SP寄存器中。如果堆栈段被设置成一个下扩数据段，这个B标志也同时指定了堆栈段的上界限。
  • 下扩数据段。此时该标志称为B标志，用于指明堆栈段的上界限。如果设置了该标志，则堆栈段的上界限是0xFFFFFFFF（4GB）；如果没有设置该标志，则堆栈段的上界限是0xFFFF（64KB）。

G
  粒度标志G（Granularity）：该字段用于确定段限长字段Limit值的单位。如果颗粒度标志为0，则段限长值的单位是字节；如果设置了颗粒度标志，则段限长值使用4KB单位。（这个标志不影响段基地址的颗粒度，基地址的颗粒度总是字节单位。）若设置了G标志，那么当使用段限长来检查偏移值时，并不会去检查偏移值的12位最低有效位。例如，当G=1时，段限长为0表明有效偏移值为0～4095。

L
  64位代码段标志L（64-bits code segment）：在IA-32模式，第二个双字的第21字节指示一个代码的是否包含本地64位代码。L置1表示这个代码段的指令执行在64位模式，置0表示执行在兼容模式。如果L位被设置了，那么D标志一定要置0。当不处于IA-32e模式时，和对于非代码段，这个位被保留并且总是应该被置0。

AVL
  可用和保留位AVL（Available and reserved bits）：段描述符第2个双字的第20字节可供系统软件使用。

---

# 七、段选择子

段选择子是一个16位的段描述符，段选择子格式，如图：
![](编程语言-1-汇编/res/23.png)

- INDEX：在GDT数组或LDT数组的索引号(3~15位)
- TI：Table Indicator,这个值为0表示查找GDT，1则查找LDT
- RPL：请求特权级。以什么样的权限去访问段。

**练习**
给出下列3个段选择子，从GTD表中查找对应的段描述符，然后填充到段寄存器中。

将段描述符填写到段寄存器结构体中（段选择子：23， 2B ，30 )

0x23 拆分为二进制为 ： 0010 0011
```html
RPL ：11 (低2位)
TI ：0 (第3位)
INDEX : 100 (3~15位)
表明查找GDT表，Index 是4。对应GDT表项是00cff300`0000ffff
WORD Selector: 23
WORD Atrribute: cff3
DWORD Base: 00000000
DWORD Limit: ffffffff
```
0x2B 拆分为二进制为 ：00101 0 11
```html
RPL ：11 (低2位)
TI ：0 (第3位)
INDEX : 101 (3~15位)
表明查找GDT表，Index 是5。对应GDT表项是80008b04`200020ab
WORD Selector: 2B
WORD Atrribute: 008b
DWORD Base: 80042000
DWORD Limit:000020ab
```
0x30 拆分为二进制为 ：00110 0 00
```html
RPL ：00 (低2位)
TI ：0 (第3位)
INDEX : 110 (3~15位)
表明查找GDT表，Index 是6。对应GDT表项是ffc093df`f0000001
WORD Selector: 30
WORD Atrribute: c093
DWORD Base: ffdff000
DWORD Limit: 00001fff
```

---

# 七、加载段描述符至段寄存器

mov 指令修改段寄存器，例如：
```asm
mov ax, 0x20
mov ds, ax
```

除了 MOV 指令，我们还可以使用 LES、LSS、LDS、LFS、LGS 指令修改寄存器.

CS 不能通过上述的指令进行修改，CS 为代码段，CS 的改变会导致 EIP 的改变，要改 CS，必须要保证 CS 与 EIP 一起改。
```c
int main()
{
       char buffer[6] = {0};
       __asm {
              // 高 2 字节加载到 ES 寄存器，低 4 字节复制到 ecx 寄存器。fword 表示 6 字节。
              // LDS/LSS/LFS/LGS 用法是类似的。没有LCS指令，要修改CS，需要使用其它指令，这里就不给出。
              // 这行指令是有坑的，不一定可以执行成功，取决于buffer中的值。
              les ecx, fword ptr ds:[buffer]
       }
       return 0;
}
```
注意：RPL<=DPL(在数值上)

---

# 八、分析 limit

limit 的含义是这个段的大小。 LIMIT 表示段描述符中的 20bit LIMIT。

如果粒度 G=0，LIMIT= 0x3ff，这意味着该段的大小是 0x3ff+1=0x400 字节。如果 G=1，那意味着该段的大小是(0x3ff+1)*4KB=0x400000字节，所以换算后的 limit = 0x400000-1=0x003fffff.

再举个例子。LIMIT=0xfffff, G=1,则该段的大小是 `(0xfffff+1)*4KB=0x100000*0x1000=0x100000000字节，所以换算后的 limit=0x100000000-1=0xffffffff`

limit 只有20个位，如何赋给32位呢 ？

当属性里的G位为0时，在limit 高位添加12个0，扩展为32位。比如 0x003ff，然后在前面补 0 至32bit，即 limit = 0x000003ff；

当G位为1时，在limit 低位添加12 个1(二进制)，扩展成32 位。比如 0x003ff，然后在后面补 f 至 32bit，即 LIMIT = 0x003fffff

---

> 版权声明©：
>
> 本文为 CHA.ATY 的原创文章，遵循 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/) 许可证进行授权，转载请附上原文出处链接及本声明。
>
> 作者：CHA.ATY
>
> 邮箱：2165150141@qq.com